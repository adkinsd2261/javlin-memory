Upgrade my Flask memory system to support intelligent, passive logging based on the build process and chat context. I want the system to capture only meaningful events ‚Äî autonomously, but selectively ‚Äî as if it's a cofounder tracking what matters.

1. üì• Passive Autologging
Create a function autolog_memory() that:

Inspects recent instructions, responses, or build behavior

Detects important events (e.g., bug fix, milestone, decision, insight)

Auto-generates a memory log without needing user input

Uses the following schema:

json
Copy
Edit
{
  "topic": "...",
  "type": "...",
  "input": "...",
  "output": "...",
  "score": 25,
  "maxScore": 25,
  "success": true,
  "category": "...",
  "tags": ["..."],
  "context": "...",
  "related_to": ["..."],
  "reviewed": false
}
Integrate this so that POST /memory can run fully automatically (no required fields), defaulting to autolog_memory() logic when fields are missing.

2. üè∑Ô∏è Auto-Tagging + Context Capture
Auto-generate tags from input and output using keyword or NLP logic (e.g., "bug", "fix", "decision", "milestone").

Generate a context string summarizing:

What the user was trying to do

What they struggled with

How they succeeded (or not)

Example:
"Resolved API route bug after 3 failed attempts. Switched from localhost to external IP for /digest access."

3. üîó Memory Linking
Add a related_to field and implement logic to link new logs to previous ones with similar topic, tags, or category.

This enables narratives: problem ‚Üí attempt ‚Üí fix ‚Üí insight.

4. üß† Importance Scoring Filter
Implement a scoring model (0‚Äì100) for memory significance:

Impact (0‚Äì30), Resolution (0‚Äì20), Novelty (0‚Äì20), Emotion (0‚Äì20), Reflection (0‚Äì10)

Only auto-log if score ‚â• 60.

Always log these types: BugFix, Insight, BuildLog, Decision, Emotion.

Skip redundant or trivial logs.

Optional: buffer low-score logs for later review or summary.

5. üíæ Manual + Passive Flexibility
Keep full manual POST /memory supported

Prioritize passive autologging as default behavior for the system

Ensure the endpoint is production-ready and logs to existing storage or backend API